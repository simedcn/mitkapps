/*===================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center,
Division of Medical and Biological Informatics.
All rights reserved.

This software is distributed WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

See LICENSE.txt or http://www.mitk.org for details.

===================================================================*/

#include "AwesomeView.h"

#include <berryISelectionService.h>
#include <berryIWorkbenchWindow.h>

#include <usModuleRegistry.h>
#include <QmitkDataStorageComboBox.h>

#include <QMessageBox>
#include <QPainter>
#include <QColorDialog>

#include <AwesomeImageFilter.h>
#include <AwesomeImageInteractor.h>

#include "mitkLabel.h"
#include "mitkToolManagerProvider.h"

// Helper function to create a fully set up instance of our
// AwesomeImageInteractor, based on the state machine specified in Paint.xml
// as well as its configuration in PaintConfig.xml. Both files are compiled
// into our MyAwesomeLib module as resources.
//static AwesomeImageInteractor::Pointer CreateAwesomeImageInteractor()
//{
//  auto myAwesomeLib = us::ModuleRegistry::GetModule("MyAwesomeLib");

//  auto interactor = AwesomeImageInteractor::New();
//  interactor->LoadStateMachine("Paint.xml", myAwesomeLib);
//  interactor->SetEventConfig("PaintConfig.xml", myAwesomeLib);

//  return interactor;
//}

// Don't forget to initialize the VIEW_ID.
const std::string AwesomeView::VIEW_ID = "my.awesomeproject.views.awesomeview";

void AwesomeView::CreateQtPartControl(QWidget* parent)
{
  // Setting up the UI is a true pleasure when using .ui files, isn't it?
  m_Controls.setupUi(parent);
  this->GetRenderWindowPart(OPEN);
  this->RequestRenderWindowUpdate();
  // Wire up the UI widgets with our functionality.

  m_ToolManager = mitk::ToolManagerProvider::GetInstance()->GetToolManager();
  assert(m_ToolManager);

  SetLabelWidget();
}

void AwesomeView::SetFocus()
{

}

void AwesomeView::SetLabelWidget()
{
  QTableWidget *tableWidged = m_Controls.m_LabelSetTableWidget;

  tableWidged->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Maximum);
  tableWidged->setTabKeyNavigation(false);
  tableWidged->setAlternatingRowColors(false);
  tableWidged->setFocusPolicy(Qt::NoFocus);
  tableWidged->setColumnCount(4);
  tableWidged->resizeColumnToContents(NAME_COL);
  tableWidged->setColumnWidth(LOCKED_COL, 25);
  tableWidged->setColumnWidth(COLOR_COL, 25);
  tableWidged->setColumnWidth(VISIBLE_COL, 25);
#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
  tableWidged->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch);
#else
  tableWidged->horizontalHeader()->setResizeMode(0, QHeaderView::Stretch);
#endif
  tableWidged->setContextMenuPolicy(Qt::CustomContextMenu);
  tableWidged->horizontalHeader()->hide();
  tableWidged->setSortingEnabled(false);
  tableWidged->verticalHeader()->hide();
  tableWidged->setEditTriggers(QAbstractItemView::NoEditTriggers);
  tableWidged->setSelectionMode(QAbstractItemView::ExtendedSelection);
  tableWidged->setSelectionBehavior(QAbstractItemView::SelectRows);

  connect(tableWidged, SIGNAL(itemClicked(QTableWidgetItem *)), this, SLOT(OnItemClicked(QTableWidgetItem *)));
  connect(
    tableWidged, SIGNAL(itemDoubleClicked(QTableWidgetItem *)), this, SLOT(OnItemDoubleClicked(QTableWidgetItem *)));
  connect(tableWidged,
    SIGNAL(customContextMenuRequested(const QPoint &)),
    this,
    SLOT(OnTableViewContextMenuRequested(const QPoint &)));
 
}

void AwesomeView::OnColorButtonClicked()
{
  int row = -1;
  for (int i = 0; i < m_Controls.m_LabelSetTableWidget->rowCount(); ++i)
  {
    if (sender() == m_Controls.m_LabelSetTableWidget->cellWidget(i, COLOR_COL))
    {
      row = i;
    }
  }

  if (row >= 0 && row < m_Controls.m_LabelSetTableWidget->rowCount())
  {
    std::string name_selected = m_Controls.m_LabelSetTableWidget->item(row, 0)->data(Qt::UserRole).toString().toStdString();
    //std::string name_selected = m_Controls.m_LabelSetTableWidget->item(row, 0)->text().toStdString();
    float rgb[3];
    mitk::DataNode* node_selected = GetDataStorage()->GetNamedNode(name_selected);
    node_selected->GetColor(rgb);
    mitk::Color color;
    color.SetRed(rgb[0]);
    color.SetGreen(rgb[1]);
    color.SetBlue(rgb[2]);
    QColor initial(color.GetRed() * 255, color.GetGreen() * 255, color.GetBlue() * 255);
    QColor qcolor = QColorDialog::getColor(initial, 0, QString("Change color"));
    if (!qcolor.isValid())
    {
      return;
    }

    QPushButton *button = static_cast<QPushButton*>(m_Controls.m_LabelSetTableWidget->cellWidget(row, COLOR_COL));
    if (!button)
    {
      return;
    }

    button->setAutoFillBackground(true);

    QString styleSheet = "background-color:rgb(";
    styleSheet.append(QString::number(qcolor.red()));
    styleSheet.append(",");
    styleSheet.append(QString::number(qcolor.green()));
    styleSheet.append(",");
    styleSheet.append(QString::number(qcolor.blue()));
    styleSheet.append(")");
    button->setStyleSheet(styleSheet);

    mitk::Color newColor;
    newColor.SetRed(qcolor.red() / 255.0);
    newColor.SetGreen(qcolor.green() / 255.0);
    newColor.SetBlue(qcolor.blue() / 255.0);

    node_selected->SetColor(newColor);
  }
}

void AwesomeView::OnSelectionChanged(berry::IWorkbenchPart::Pointer, const QList<mitk::DataNode::Pointer>& dataNodes)
{
  MITK_INFO << dataNodes.size();

  for (const auto& dataNode : dataNodes)
  {
    // Write robust code. Always check pointers before using them. If the
    // data node pointer is null, the second half of our condition isn't
    // even evaluated and we're safe (C++ short-circuit evaluation).
    if (dataNode.IsNotNull() && dynamic_cast<mitk::Image*>(dataNode->GetData()) != nullptr)
    {
      m_Controls.selectImageLabel->setVisible(false);
      
      std::string imgName;
      dataNode->GetStringProperty("name", imgName);
      MITK_INFO << imgName;
      //m_ToolManager->SetWorkingData(dataNode);

      std::string patientName;
      patientName = dataNode->GetStringProperty("dicom.patient.PatientsName", patientName);
      MITK_INFO << patientName;

      SetLabelWidget();

      m_Controls.PatientName_label->setText(QString::fromStdString(patientName));
      return;
    }
  }
  

  // Nothing is selected or the selection doesn't contain an image.
  m_Controls.selectImageLabel->setVisible(true);
}

void AwesomeView::NodeAdded(const mitk::DataNode *node)
{
  bool binary = false;
  node->GetBoolProperty("binary", binary);
  bool segmentation = false;
  node->GetBoolProperty("binary", segmentation);
  if (!binary || !segmentation)
    return;

  itk::SmartPointer<mitk::Label> label = mitk::Label::New();
  std::string name;
  node->GetStringProperty("name", name);
  label->SetName(name);

  float rgb[3];
  node->GetColor(rgb);
  mitk::Color color;
  color.SetRed(rgb[0]);
  color.SetGreen(rgb[1]);
  color.SetBlue(rgb[2]);

  QString styleSheet = "background-color:rgb(";
  styleSheet.append(QString::number(color[0] * 255));
  styleSheet.append(",");
  styleSheet.append(QString::number(color[1] * 255));
  styleSheet.append(",");
  styleSheet.append(QString::number(color[2] * 255));
  styleSheet.append(")");
  QTableWidget* tableWidget = m_Controls.m_LabelSetTableWidget;
  int colWidth = (tableWidget->columnWidth(NAME_COL) < 180) ? 180 : tableWidget->columnWidth(NAME_COL) - 2;
  QString text = tableWidget->fontMetrics().elidedText(label->GetName().c_str(), Qt::ElideMiddle, colWidth);
  QTableWidgetItem *nameItem = new QTableWidgetItem(text);
  nameItem->setTextAlignment(Qt::AlignCenter | Qt::AlignLeft);
  // ---!---
  // IMPORTANT: ADD PIXELVALUE TO TABLEWIDGETITEM.DATA
  
  nameItem->setData(Qt::UserRole, QVariant(QString::fromStdString(name)));
  // ---!---

  QPushButton *pbColor = new QPushButton(tableWidget);
  pbColor->setFixedSize(24, 24);
  pbColor->setCheckable(false);
  pbColor->setAutoFillBackground(true);
  pbColor->setToolTip("Change label color");
  pbColor->setStyleSheet(styleSheet);

  connect(pbColor, SIGNAL(clicked()), this, SLOT(OnColorButtonClicked()));

  QPushButton *pbLocked = new QPushButton(tableWidget);
  pbLocked->setFixedSize(24, 24);
  QIcon *iconLocked = new QIcon();

  iconLocked->addFile(QString::fromUtf8(":/Qmitk/lock.png"), QSize(), QIcon::Normal, QIcon::Off);
  iconLocked->addFile(QString::fromUtf8(":/Qmitk/unlock.png"), QSize(), QIcon::Normal, QIcon::On);
  pbLocked->setIcon(*iconLocked);
  pbLocked->setIconSize(QSize(24, 24));
  pbLocked->setCheckable(true);
  pbLocked->setToolTip("Lock/unlock label");
  pbLocked->setChecked(!label->GetLocked());
  connect(pbLocked, SIGNAL(clicked()), this, SLOT(OnLockedButtonClicked()));

  QPushButton *pbVisible = new QPushButton(tableWidget);
  pbVisible->setFixedSize(24, 24);
  pbVisible->setAutoRepeat(false);
  QIcon *iconVisible = new QIcon();
  iconVisible->addFile(QString::fromUtf8(":/Qmitk/visible.png"), QSize(), QIcon::Normal, QIcon::Off);
  iconVisible->addFile(QString::fromUtf8(":/Qmitk/invisible.png"), QSize(), QIcon::Normal, QIcon::On);
  pbVisible->setIcon(*iconVisible);
  pbVisible->setIconSize(QSize(24, 24));
  pbVisible->setCheckable(true);
  pbVisible->setToolTip("Show/hide label");
  pbVisible->setChecked(!label->GetVisible());

  connect(pbVisible, SIGNAL(clicked()), this, SLOT(OnVisibleButtonClicked()));

  MITK_INFO << "Hierher gehts schon";
  int row = tableWidget->rowCount();
  tableWidget->insertRow(row);
  tableWidget->setRowHeight(row, 24);
  tableWidget->setItem(row, 0, nameItem);
  tableWidget->setCellWidget(row, 1, pbLocked);
  tableWidget->setCellWidget(row, 2, pbColor);
  tableWidget->setCellWidget(row, 3, pbVisible);
  tableWidget->selectRow(row);

  // m_LabelSetImage->SetActiveLabel(label->GetPixelValue());
  // m_ToolManager->WorkingDataModified.Send();
  // emit activeLabelChanged(label->GetPixelValue());

  if (tableWidget->rowCount() == 0)
  {
    tableWidget->hideRow(row); // hide exterior label
  }
}

mitk::DataNode *AwesomeView::GetWorkingNode()
{
<<<<<<< HEAD
  MITK_INFO << dataNodes.size();

  for (const auto& dataNode : dataNodes)
  {
    // Write robust code. Always check pointers before using them. If the
    // data node pointer is null, the second half of our condition isn't
    // even evaluated and we're safe (C++ short-circuit evaluation).
    if (dataNode.IsNotNull() && dynamic_cast<mitk::Image*>(dataNode->GetData()) != nullptr)
    {
      m_Controls.selectImageLabel->setVisible(false);

      std::string imgName;
      dataNode->GetStringProperty("name", imgName);
      MITK_INFO << imgName;

      std::string patientName = dataNode->GetData()->GetProperty("DICOM.0010.0010")->GetValueAsString();
      MITK_INFO << patientName;

      SetLabelWidget();

      m_Controls.PatientName_label->setText(QString::fromStdString(patientName));
      return;
    }
  }


  // Nothing is selected or the selection doesn't contain an image.
  m_Controls.selectImageLabel->setVisible(true);
}

=======
  mitk::DataNode *workingNode = m_ToolManager->GetWorkingData(0);
  assert(workingNode);
  return workingNode;
}
>>>>>>> c87673ba561d2e6c211f8fd2500d44e365402c11
